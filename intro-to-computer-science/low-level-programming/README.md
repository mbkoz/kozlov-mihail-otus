
# INTRO TO COMPUTER SCIENCE 4

### Задача 1: самая длинная последовательность

#### Условие

Дан массив, который состоит из нулей и единиц. Выведите размер самой длинной непрерывной последовательности единиц в массиве.

Пример: `[0, 0, 1, 0, 1, 1, 1, 0]`
Ответ:  `3`

Пример: `[0, 0, 0]`
Ответ:  `0`

**Ограничения:**

- `0 < n < 50`, где `n` — длина массива
- массив состоит только из чисел `0` и `1`

#### Решение

**файл с решением:** longest_seq.asm

**аргументы программы**
Для изменения аргументов программы необходимо изменить значения метки памяти `arr` в файле исходного кода (см. ниже)  
```nasm
section .data
    arr db  1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0
```
Длина массива вычисляется автоматически

**сборка решения**
Текущий рабочий каталог для исполнения команд должен располагаться в корневом каталоге проекта.  
Сборка программы:  

```shell
make longest_seq
```

Запуск отладки:  

```shell
make longest_seq_gdb
```

После запуска отладки необходимо нажать **ENTER**

### Задача 2: беготня по этажам

#### Условие

Вася бегает по этажам офисного здания с блокнотом в руках:

- когда он поднимается на 1 этаж, он записывает букву `u`
- когда он опускается  на 1 этаж, он записывает букву `d`

Определите по записям в блокноте (есть минимум 1 запись), смог ли Вася вернуться на исходный этаж в конце рабочего дня:

- выведите `1`, если Вася закончил работать там же, где начал
- выведите `0`, если Вася застрял на другом этаже

Пример: `['u', 'd', 'd', 'u', 'u', 'd', 'd', 'u']`
Ответ:  `1`

Пример: `['u', 'u', 'u']`
Ответ:  `0` (Вася закончил на 3 этажа выше)

**Ограничения:**

- `0 < n < 50`, где `n` — длина массива
- массив состоит только из символов `u` и `d`

#### Решение

**файл с решением:** up_down.asm

**аргументы программы**
Для изменения аргументов программы необходимо изменить значения метки памяти `arr` в файле исходного кода (см. ниже)  
```nasm
section .data
    arr db  'u', 'd', 'd', 'u', 'u', 'd', 'd', 'u', 'u'
```
**сборка решения**
Текущий рабочий каталог для исполнения команд должен располагаться в корневом каталоге проекта.  
Сборка программы:  

```shell
make up_down
```

Запуск отладки:  

```shell
make up_down_gdb
```

После запуска отладки необходимо нажать **ENTER**

### Задача 3: ближайший тёплый день

#### Условие

Детям в школе задали на лето записывать каждый день:

- какая в этот день была температура
- если до этого были дни с более высокой температурой — записать температуру **ближайшего** такого дня (или -1, если таких дней не было)

Помогите Маше найти ближайшие предыдущие дни с более высокой температурой. 

ВАЖНО: решение должно выполняться за время O(n).

Пример: `[17, 21, 13, 17, 14, 12]`
Ответ:  `[-1, -1, 21, 21, 17, 14]`

**Ограничения:**

- `0 < n < 50`, где `n` — длина массива
- `0 < arr[i] < 50` для любого индекса `i` в массиве

#### Решение

**файл с решением:** wday_search.asm

**аргументы программы**
Для изменения аргументов программы необходимо изменить значения метки памяти `arr` в файле исходного кода (см. ниже)  
```nasm
section .data
    arr dd  17, 21, 13, 17, 14, 12
```
**сборка решения**
Текущий рабочий каталог для исполнения команд должен располагаться в корневом каталоге проекта.  
Сборка программы:  

```shell
make wday_search
```

Запуск отладки:  

```shell
make wday_search_gdb
```

После запуска отладки необходимо нажать **ENTER**

**Алгоритм решения:**

0. Помещение в стек температур -1, которое в беззнаковом представлении является самой жаркой погодой
1. загрузка очередного значения температуры в регистр
2. разворачивание стека температур(последовательно извлекая элементы с вершины) пока не будет найден более теплый день (чем день в загруженный в регистр)
3. вывод вершины стека (-1 если стек полностью развернут)
4. помещение загруженного в регистр значения температуры в стек
5. проверка того, что во входной очереди еще есть значение новой температуры. Переход в п.1 если есть или завершение работы если нет

Данный алгоритм обеспечивает сложность решения O(n)

### Задача 3: ближайший тёплый день (STDIO EDTION)

**Комментарии:**
1. Задача переделана на ввод/вывод из стандартного потока
2. Это просто эксперименты с некоторыми особенностями NASM.
3. Для реализации ввода/вывода строк и чисел использованы функции с системными вызовами read/write
4. для удобства передачи аргументов в функции добавлены многострочные макросы (хотя это спорное решение)

**файл с решением:** wday_search_ext.asm

**сборка решения**
Текущий рабочий каталог для исполнения команд должен располагаться в корневом каталоге проекта.  
Сборка программы:  

```shell
make wday_search_ext
```

Запуск отладки:  

```shell
make wday_search_ext_gdb
```

После запуска отладки необходимо нажать **ENTER**
