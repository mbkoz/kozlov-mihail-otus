.ORIG x3000
    ; вывели приглашение на ввод
    LEA R0, INPUT_PROMPT
    PUTS
    ; считаем адрес, в котором будет располагаться строка и длину буфера
    LEA R1, STR_BUF_PTR
    LD R2, STR_LEN
    ; передвинем указатель (R1) на конец буфера, т.к. строка будет размещаться из конца в начало
    ADD R1, R1, R2  ;R1 указывает на регистр следующий за буфером
    ; считаем терминирующий символ
    LD R3 LFEED_NEG
    ; "считаем" из ввода "конец строки"
    AND R0, R0, #0
    ; разместим ввод и будем читать символы, пока не введут LF или буфер не кончится
READ_SYM
    ADD R1, R1, #-1
    STR R0, R1, #0
    OUT                 ; вывод эха разместили здесь, чтобы LF не вывелся
    ADD R2, R2, #-1     ; уменьаем счетчик оставшегося места
    BRz READ_SYM_END    ; проверяем есть ли место в буфере
    GETC                ; читаем следующий символ (если место есть)
    ADD R4, R0, R3      ; сравниваем с LF
    BRnp READ_SYM

READ_SYM_END
    ; выведем приглашение на вывод
    LEA R0, OUTPUT_PROMPT
    PUTS
    ; выведем введенные символы в обратном порядке
    AND R0, R0, #0
    ADD R0, R0, R1
    PUTS

    HALT    ; Всегда должно быть при завершении программы

INPUT_PROMPT    .STRINGZ    "ENTER BINARY VALUE: "  ; метка, с записанным приглашением на ввод
OUTPUT_PROMPT   .STRINGZ    "\nREVERSED: "
STACK_PTR       .FILL       xF000                   ; метка, с указателем на область в которой будет
                                                    ; размещаться стек для регистров ядра
LFEED_NEG       .FILL       x-000A                  ; -"символ конца строки"
STR_LEN         .FILL       #5                      ; длина буффера для хранения строки
STR_BUF_PTR     .BLKW       #5                      ; сброшеный в 0 буфер для размещения строки

.END
