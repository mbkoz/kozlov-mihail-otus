; каждая новая вызываемая функция может менять рабочие регистры
; неопределенным образом (для вызывающего кода)
; например TRAP GETC изменяет R0 и R7
; Для сохранения состояния регистров вызывающего кода
; необходимо записать их в отдельный участок памяти
; для организации такого хранения можно использовать стек
; стек будет размещаться по определенному адресу
; каждый вызов (или ПЕРЕД каждым вызовом) состояние регистров
; текущей функции будет сохроняться в стеке.
; скорее всего, для работы функций будет хватать только рабочих регистров
; по этому стек будет использоваться только для хранения рабочих регистров
; передача аргументов в функции и прием возвращаемого значения так же будет 
; через рабочие регистры. Вызывающий код будет готовить значения
; в зависимости от требований вызываемого кода
; для хранения вершины стека будет использовать R6 (R7 для адреса возврата) 

.ORIG x3000
    ; первым делом сохраним вершину стека
    LD R6, STACK_PTR
    ; вывели приглашение на ввод
    LEA R0, INPUT_PROMPT
    PUTS
    ; считаем адрес, в котором будет располагаться строка и длину буфера
    LEA R1, STR_BUF_PTR
    LD R2, STR_LEN
    ; передвинем указатель (R1) на конец буфера, т.к. строка будет размещаться из конца в начало
    ADD R1, R1, R2  ;R1 указывает на регистр следующий за буфером
    ; считаем терминирующий символ
    LD R3 LFEED_NEG
    ; "считаем" из ввода "конец строки"
    AND R0, R0, #0
    ; разместим ввод и будем читать символы, пока не введут LF или буфер не кончится
READ_SYM
    ADD R1, R1, #-1
    STR R0, R1, #0
    OUT                 ; вывод эха разместили здесь, чтобы LF не вывелся
    ADD R2, R2, #-1     ; уменьаем счетчик оставшегося места
    BRz READ_SYM_END    ; проверяем есть ли место в буфере
    GETC                ; читаем следующий символ (если место есть)
    ADD R4, R0, R3      ; сравниваем с LF
    BRnp READ_SYM

READ_SYM_END
    ; выведем приглашение на вывод
    LEA R0, OUTPUT_PROMPT
    PUTS
    ; выведем введенные символы в обратном порядке
    AND R0, R0, #0
    ADD R0, R0, R1
    PUTS

    HALT    ; Всегда должно быть при завершении программы


PUSH_STACK  ; функция для сохранения состояния рабочих регистров (кроме R7)
    STR R0, R6, #0
    STR R1, R6, #1
    STR R2, R6, #2
    STR R3, R6, #3
    STR R4, R6, #4
    STR R5, R6, #5
    STR R6, R6, #6  ; так же будет сохраняться адрес предыдущего стек фрейма
    ADD R6, R6, #7
    RET


POP_STACK   ; восстановление состояния рабочих регистров
    
    RET

STACK_PTR       .FILL       xF000                   ; метка, с указателем на область в которой будет
                                                    ; размещаться стек для регистров ядра
LFEED_NEG       .FILL       x-000A                  ; -"символ конца строки"
STR_LEN         .FILL       #10                     ; длина буффера для хранения строки
STR_BUF_PTR     .BLKW       #10                     ; сброшеный в 0 буфер для размещения строки

INPUT_PROMPT    .STRINGZ    "ENTER BINARY VALUE: "  ; метка, с записанным приглашением на ввод
OUTPUT_PROMPT   .STRINGZ    "\nREVERSED: "
.END
