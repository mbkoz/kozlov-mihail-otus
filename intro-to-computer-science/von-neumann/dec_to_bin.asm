; R0 - регистр для возврата значений (или указателя на значение)
; R1...R5 - регистры для хранения данных вызова
; R6 - указатель на вершину стека
; R7 - хранит адрес возврата
;!!!!! симулятор не сбрасывает память .BLKW. Для сброса необходимо пересобрать

.ORIG x3000
MAIN
    LD R6, STACK_PTR        ; сохраним вершину стека
    LEA R0, INPUT_PROMPT    ; вывели приглашение на ввод
    PUTS
    ; считаем десятичное число (сразу в bin представлении)
    ; выведем двоичное представление числа (отрезав lead 0's)

    JSR READ_NUM_FUNC       ; считаем десятичное число в r0
    HALT

NEG_LFEED   .FILL   x-000A  ; -'\n'
NEG_0       .FILL   x-30    ; -'0'
NEG_9       .FILL   x-39    ; -'9'

READ_DIGIT_FUNC     ; функция для чтения цифры из входного потока или LF если нажат ENTER
    STR R7, R6, #0  ; сначала надо сохранить адрес возврата
    ADD R6, R6, #1
    JSR PUSH_STACK  ; т.к. данный вызов его перепишет
    LD R1, NEG_0
    LD R2, NEG_9
    LD R3, NEG_LFEED
READ_CHAR
    GETC 
    ADD R4, R0, R3
    BRz END_READ_CHAR   ; считали LF
    ADD R4, R0, R1
    BRn READ_CHAR
    ADD R4, R0, R2
    BRp READ_CHAR
    OUT
    ADD R0, R0, R1  ; вычитаем смещение, чтобы вернуть считанное число
END_READ_CHAR
    JSR POP_STACK
    ADD R6, R6, #-1
    LDR R7, R6, #0
    RET

MULTx10_FUNC ; увеличивает в 10 раз R0 (R0->R0)
    STR R7, R6, #0  ; сначала надо сохранить адрес возврата
    ADD R6, R6, #1
    JSR PUSH_STACK  ; т.к. данный вызов его перепишет
    ADD R0, R0, R0; R0=2x
    ADD R1, R0, R0; R1 = 4x
    ADD R1, R1, R1; R1 = 8x
    ADD R0, R1, R0; R0 = 10x
    JSR POP_STACK
    ADD R6, R6, #-1
    LDR R7, R6, #0
    RET

STR_LEN         .FILL       #6              ; длина буффера для хранения строки
STR_BUF_PTR     .BLKW       #6              ; сброшеный в 0 буфер для размещения строки

; функция последовательно читает цифры из ввода до нажатия '\n'
; после завершения выполнения в R0 выозвращает введенное dec число
; R0 - будет использоваться для приема символа от GETC, для умножения в MULTx10 и для взврата результата
; R1 - число, к котое после очередного ввода цифры будет x10 и прибавляться ввод
; R2 - хранит -'\n' для сравнения
; R3 - временное хранилище

READ_NUM_FUNC
    STR R7, R6, #0  ; сначала надо сохранить адрес возврата
    ADD R6, R6, #1
    JSR PUSH_STACK  ; т.к. данный вызов его перепишет

    AND R1, R1, #0  ; R1 будет хранить конечный результат
    LD R2, NEG_LFEED

READ_NEX_DIGIT_BEGIN
    JSR READ_DIGIT_FUNC
    ADD R4, R0, R2  ; проверили, что ввод не '\n'
    BRz GET_NEXT_DIGIT_END
    AND R3, R3, #0
    ADD R3, R3, R0 ; перенести считанный символ R0 в R3
    AND R0, R0, #0
    ADD R0, R0, R1 ; перенесли число в R0 для умножения
    JSR MULTx10_FUNC
    ADD R0, R0, R3 ; прибавили то, что считали
    AND R1, R1, #0
    ADD R1, R1, R0 ; перенесли результат в R1
    BRnzp READ_NEX_DIGIT_BEGIN
GET_NEXT_DIGIT_END
    AND R0, R0, #0
    ADD R0, R0, R1 ; перенос в R0 для возврата значения
    JSR POP_STACK
    ADD R6, R6, #-1
    LDR R7, R6, #0
    RET

PUSH_STACK  ; функция для сохранения состояния рабочих регистров
    ;STR R0, R6, #0
    STR R1, R6, #1
    STR R2, R6, #2
    STR R3, R6, #3
    STR R4, R6, #4
    STR R5, R6, #5
    STR R6, R6, #6  ; так же будет сохраняться адрес предыдущего стек фрейма
    ADD R6, R6, #7  ; указатель стека указывает на следующую ячейку, которая не занята
    RET

POP_STACK   ; восстановление состояния рабочих регистров
    ;LDR  R0, R6, #-7
    LDR  R1, R6, #-6
    LDR  R2, R6, #-5
    LDR  R3, R6, #-4
    LDR  R4, R6, #-3
    LDR  R5, R6, #-2
    LDR  R6, R6, #-1    ; теперь R6 хранит указатель предыдущего состояния вершины
    RET

STACK_PTR       .FILL       xF000           ; метка, с указателем на область в которой будет
                                            ; размещаться стек для регистров ядра

INPUT_PROMPT    .STRINGZ    "ENTER NUMBER: "; метка, с записанным приглашением на ввод
OUTPUT_PROMPT   .STRINGZ    "\nBINARY: "
.END
